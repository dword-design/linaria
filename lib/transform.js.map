{"version":3,"sources":["../src/transform.js"],"names":["STYLIS_DECLARATION","module","exports","transform","code","options","test","sourceMap","inputSourceMap","pluginOptions","ast","babel","parseSync","babelOptions","filename","caller","name","createParenthesizedExpressions","transformFromAstSync","presets","require","resolve","babelrc","configFile","sourceMaps","sourceFileName","metadata","transformedCode","map","linaria","rules","replacements","dependencies","mappings","cssText","preprocessor","selector","text","stylis","use","context","decl","outputFilename","replace","match","p1","p2","p3","path","relative","dirname","Object","keys","forEach","index","push","generated","line","column","original","start","cssSourceMapText","length","generator","SourceMapGenerator","file","mapping","addMapping","assign","source","setSourceContent","toString"],"mappings":";;;;;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;;;AA0CA,IAAMA,kBAAkB,GAAG,CAA3B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,IAAnB,EAAiCC,OAAjC,EAA2D;AAC1E;AACA;AACA,MAAI,CAAC,iBAAiBC,IAAjB,CAAsBF,IAAtB,CAAL,EAAkC;AAChC,WAAO;AACLA,MAAAA,IAAI,EAAJA,IADK;AAELG,MAAAA,SAAS,EAAEF,OAAO,CAACG;AAFd,KAAP;AAID;;AAED,MAAMC,aAAa,GAAG,0BAAYJ,OAAO,CAACI,aAApB,CAAtB,CAV0E,CAY1E;AACA;;AACA,MAAMC,GAAG,GAAGC,KAAK,CAACC,SAAN,CAAgBR,IAAhB,oBACNK,aAAa,GAAGA,aAAa,CAACI,YAAjB,GAAgC,IADvC;AAEVC,IAAAA,QAAQ,EAAET,OAAO,CAACS,QAFR;AAGVC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAHE;AAIVC,IAAAA,8BAA8B,EAAE;AAJtB,KAAZ;;AAd0E,8BAqBzBN,KAAK,CAACO,oBAAN,CAC/CR,GAD+C,EAE/CN,IAF+C,EAG/C;AACEU,IAAAA,QAAQ,EAAET,OAAO,CAACS,QADpB;AAEEK,IAAAA,OAAO,EAAE,CAAC,CAACC,OAAO,CAACC,OAAR,CAAgB,SAAhB,CAAD,EAA6BZ,aAA7B,CAAD,CAFX;AAGEa,IAAAA,OAAO,EAAE,KAHX;AAIEC,IAAAA,UAAU,EAAE,KAJd;AAKEC,IAAAA,UAAU,EAAE,IALd;AAMEC,IAAAA,cAAc,EAAEpB,OAAO,CAACS,QAN1B;AAOEN,IAAAA,cAAc,EAAEH,OAAO,CAACG;AAP1B,GAH+C,CArByB;AAAA,MAqBlEkB,QArBkE,yBAqBlEA,QArBkE;AAAA,MAqBlDC,eArBkD,yBAqBxDvB,IArBwD;AAAA,MAqBjCwB,GArBiC,yBAqBjCA,GArBiC;;AAmC1E,MAAI,CAACF,QAAQ,CAACG,OAAd,EAAuB;AACrB,WAAO;AACLzB,MAAAA,IAAI,EAAJA,IADK;AAELG,MAAAA,SAAS,EAAEF,OAAO,CAACG;AAFd,KAAP;AAID;;AAxCyE,0BA0C5BkB,QAAQ,CAACG,OA1CmB;AAAA,MA0ClEC,KA1CkE,qBA0ClEA,KA1CkE;AAAA,MA0C3DC,YA1C2D,qBA0C3DA,YA1C2D;AAAA,MA0C7CC,YA1C6C,qBA0C7CA,YA1C6C;AA2C1E,MAAMC,QAAQ,GAAG,EAAjB;AAEA,MAAIC,OAAO,GAAG,EAAd;AAEA,MAAIC,YAAJ;;AAEA,MAAI,OAAO9B,OAAO,CAAC8B,YAAf,KAAgC,UAApC,EAAgD;AAC9C;AACAA,IAAAA,YAAY,GAAG9B,OAAO,CAAC8B,YAAvB;AACD,GAHD,MAGO;AACL,YAAQ9B,OAAO,CAAC8B,YAAhB;AACE,WAAK,MAAL;AACEA,QAAAA,YAAY,GAAG,sBAACC,QAAD,EAAWC,IAAX;AAAA,iBAAuBD,QAAvB,UAAoCC,IAApC;AAAA,SAAf;;AACA;;AACF,WAAK,QAAL;AACA;AACEC,wBAAOC,GAAP,CAAW,IAAX,EAAiB,UAACC,OAAD,EAAUC,IAAV,EAAmB;AAClC,cAAID,OAAO,KAAKxC,kBAAZ,IAAkCK,OAAO,CAACqC,cAA9C,EAA8D;AAC5D;AACA;AACA,mBAAOD,IAAI,CAACE,OAAL,CACL,yBADK,EAEL,UAACC,KAAD,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;AAAA,qBACEF,EAAE,GACF;AACAG,4BAAKC,QAAL;AACE;AACAD,4BAAKE,OAAL,CAAa7C,OAAO,CAACqC,cAArB,CAFF,EAGE;AACAM,4BAAK3B,OAAL,CAAa2B,cAAKE,OAAL,CAAa7C,OAAO,CAACS,QAArB,CAAb,EAA6CgC,EAA7C,CAJF,CAFA,GAQAC,EATF;AAAA,aAFK,CAAP;AAaD;;AAED,iBAAON,IAAP;AACD,SApBD;;AAsBAN,QAAAA,YAAY,GAAGG,eAAf;AA5BJ;AA8BD;;AAEDa,EAAAA,MAAM,CAACC,IAAP,CAAYtB,KAAZ,EAAmBuB,OAAnB,CAA2B,UAACjB,QAAD,EAAWkB,KAAX,EAAqB;AAC9CrB,IAAAA,QAAQ,CAACsB,IAAT,CAAc;AACZC,MAAAA,SAAS,EAAE;AACTC,QAAAA,IAAI,EAAEH,KAAK,GAAG,CADL;AAETI,QAAAA,MAAM,EAAE;AAFC,OADC;AAKZC,MAAAA,QAAQ,EAAE7B,KAAK,CAACM,QAAD,CAAL,CAAgBwB,KALd;AAMZ5C,MAAAA,IAAI,EAAEoB;AANM,KAAd,EAD8C,CAU9C;;AACAF,IAAAA,OAAO,IAAOC,YAAY,CAACC,QAAD,EAAWN,KAAK,CAACM,QAAD,CAAL,CAAgBF,OAA3B,CAAnB,OAAP;AACD,GAZD;AAcA,SAAO;AACL9B,IAAAA,IAAI,EAAEuB,eADD;AAELO,IAAAA,OAAO,EAAPA,OAFK;AAGLJ,IAAAA,KAAK,EAALA,KAHK;AAILC,IAAAA,YAAY,EAAZA,YAJK;AAKLC,IAAAA,YAAY,EAAZA,YALK;AAMLzB,IAAAA,SAAS,EAAEqB,GANN;;AAQL,QAAIiC,gBAAJ,GAAuB;AACrB,UAAI5B,QAAQ,IAAIA,QAAQ,CAAC6B,MAAzB,EAAiC;AAC/B,YAAMC,SAAS,GAAG,IAAIC,6BAAJ,CAAuB;AACvCC,UAAAA,IAAI,EAAE5D,OAAO,CAACS,QAAR,CAAiB6B,OAAjB,CAAyB,OAAzB,EAAkC,MAAlC;AADiC,SAAvB,CAAlB;AAIAV,QAAAA,QAAQ,CAACoB,OAAT,CAAiB,UAAAa,OAAO;AAAA,iBACtBH,SAAS,CAACI,UAAV,CACEhB,MAAM,CAACiB,MAAP,CAAc,EAAd,EAAkBF,OAAlB,EAA2B;AAAEG,YAAAA,MAAM,EAAEhE,OAAO,CAACS;AAAlB,WAA3B,CADF,CADsB;AAAA,SAAxB;AAMAiD,QAAAA,SAAS,CAACO,gBAAV,CAA2BjE,OAAO,CAACS,QAAnC,EAA6CV,IAA7C;AAEA,eAAO2D,SAAS,CAACQ,QAAV,EAAP;AACD;;AAED,aAAO,EAAP;AACD;;AA1BI,GAAP;AA4BD,CA/HD","sourcesContent":["/* @flow */\n\nimport path from 'path';\nimport * as babel from '@babel/core';\nimport stylis from 'stylis';\nimport { SourceMapGenerator } from 'source-map';\nimport loadOptions, { type PluginOptions } from './babel/utils/loadOptions';\n\nexport type Replacement = {\n  original: { start: Location, end: Location },\n  length: number,\n};\n\ntype Location = {\n  line: number,\n  column: number,\n};\n\ntype Result = {\n  code: string,\n  sourceMap: ?Object,\n  cssText?: string,\n  cssSourceMapText?: string,\n  dependencies?: string[],\n  rules?: {\n    [className: string]: {\n      cssText: string,\n      displayName: string,\n      start: ?Location,\n    },\n  },\n  replacements?: Replacement[],\n};\n\ntype Options = {\n  filename: string,\n  preprocessor?: Preprocessor,\n  outputFilename?: string,\n  inputSourceMap?: Object,\n  pluginOptions?: PluginOptions,\n};\n\nexport type Preprocessor =\n  | 'none'\n  | 'stylis'\n  | ((selector: string, cssText: string) => string)\n  | void;\n\nconst STYLIS_DECLARATION = 1;\n\nmodule.exports = function transform(code: string, options: Options): Result {\n  // Check if the file contains `css` or `styled` words first\n  // Otherwise we should skip transforming\n  if (!/\\b(styled|css)/.test(code)) {\n    return {\n      code,\n      sourceMap: options.inputSourceMap,\n    };\n  }\n\n  const pluginOptions = loadOptions(options.pluginOptions);\n\n  // Parse the code first so babel uses user's babel config for parsing\n  // We don't want to use user's config when transforming the code\n  const ast = babel.parseSync(code, {\n    ...(pluginOptions ? pluginOptions.babelOptions : null),\n    filename: options.filename,\n    caller: { name: 'linaria' },\n    createParenthesizedExpressions: true,\n  });\n\n  const { metadata, code: transformedCode, map } = babel.transformFromAstSync(\n    ast,\n    code,\n    {\n      filename: options.filename,\n      presets: [[require.resolve('./babel'), pluginOptions]],\n      babelrc: false,\n      configFile: false,\n      sourceMaps: true,\n      sourceFileName: options.filename,\n      inputSourceMap: options.inputSourceMap,\n    }\n  );\n\n  if (!metadata.linaria) {\n    return {\n      code,\n      sourceMap: options.inputSourceMap,\n    };\n  }\n\n  const { rules, replacements, dependencies } = metadata.linaria;\n  const mappings = [];\n\n  let cssText = '';\n\n  let preprocessor;\n\n  if (typeof options.preprocessor === 'function') {\n    // eslint-disable-next-line prefer-destructuring\n    preprocessor = options.preprocessor;\n  } else {\n    switch (options.preprocessor) {\n      case 'none':\n        preprocessor = (selector, text) => `${selector} {${text}}\\n`;\n        break;\n      case 'stylis':\n      default:\n        stylis.use(null)((context, decl) => {\n          if (context === STYLIS_DECLARATION && options.outputFilename) {\n            // When writing to a file, we need to adjust the relative paths inside url(..) expressions\n            // It'll allow css-loader to resolve an imported asset properly\n            return decl.replace(\n              /\\b(url\\()(\\.[^)]+)(\\))/g,\n              (match, p1, p2, p3) =>\n                p1 +\n                // Replace asset path with new path relative to the output CSS\n                path.relative(\n                  /* $FlowFixMe */\n                  path.dirname(options.outputFilename),\n                  // Get the absolute path to the asset from the path relative to the JS file\n                  path.resolve(path.dirname(options.filename), p2)\n                ) +\n                p3\n            );\n          }\n\n          return decl;\n        });\n\n        preprocessor = stylis;\n    }\n  }\n\n  Object.keys(rules).forEach((selector, index) => {\n    mappings.push({\n      generated: {\n        line: index + 1,\n        column: 0,\n      },\n      original: rules[selector].start,\n      name: selector,\n    });\n\n    // Run each rule through stylis to support nesting\n    cssText += `${preprocessor(selector, rules[selector].cssText)}\\n`;\n  });\n\n  return {\n    code: transformedCode,\n    cssText,\n    rules,\n    replacements,\n    dependencies,\n    sourceMap: map,\n\n    get cssSourceMapText() {\n      if (mappings && mappings.length) {\n        const generator = new SourceMapGenerator({\n          file: options.filename.replace(/\\.js$/, '.css'),\n        });\n\n        mappings.forEach(mapping =>\n          generator.addMapping(\n            Object.assign({}, mapping, { source: options.filename })\n          )\n        );\n\n        generator.setSourceContent(options.filename, code);\n\n        return generator.toString();\n      }\n\n      return '';\n    },\n  };\n};\n"],"file":"transform.js"}